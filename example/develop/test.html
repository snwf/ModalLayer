<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    class NumberAssistant {
      /**
       * 乘法
       * 规避js处理浮点数不精确的问题.
       *
       * @Author   Wolf
       * @DateTime 2020-09-22T03:07:57+0800
       * @param    {Number}                 mul1 乘数
       * @param    {Number}                 mul2 乘数
       * @return   {Number}                      乘积
       */
      static mul (mul1, mul2) {
        let mul, carry;

        mul = [
          mul1.toString().split('.'),
          mul2.toString().split('.')
        ];

        carry = window.Math.pow(10, window.Math.max(
          mul[0][1].length ?? 0,
          mul[1][1].length ?? 0
        ));

        mul = [
          [Number(mul[0][0]), Number('0.' + mul[0][1]) * carry],
          [Number(mul[1][0]), Number('0.' + mul[1][1]) * carry]
        ];

        return (mul[0][0] !== 0 ? mul[0][0] : 1) * (mul[1][0] !== 0 ? mul[1][0] : 1) + (mul[0][1] * mul[1][1] / carry);
      }
    }
    class ObjectAssistant {
      /**
       * 获取对象上某个属性
       * 可以通过传入一串字符串或是数组进行深层的获取.
       * 若其中某一个属性值不存在则直接返回undefined;
       * 该函数行为于ES6新的运算符号?.相似.
       *
       * @Author   Wolf
       * @DateTime 2020-09-08T17:41:36+0800
       * @param    {Object}                 o 对象
       * @param    {Mixed}                  k 属性
       * @return   {Mixed}                    属性值
       */
      static get (o, k) {
        let _o, _k;
        _o = o;
        _k = Array.isArray(k) ? k : k.split('.');
        for (let i = 0; i < _k.length && !ObjectAssistant['isEmpty'](_o); i++)
          _o = _o[_k[i]];
        return _o;
      }

      /**
       * 设置一个属性到对象
       * 与默认赋值方法不同的是该方法可以通过传入一串字符串或数组进行级联赋值
       * 若父值不存在则自动赋值{}.
       * 
       * 注意:
       * 如果属性的父值不为Object则会将其重新赋值为Object.
       * 语义上该方法并不适用于数组.
       *
       * @Author   Wolf
       * @DateTime 2020-09-08T17:38:10+0800
       * @param    {Object}                 o 对象
       * @param    {Mixed}                  k 属性名称
       * @param    {Object}                 v 属性值
       */
      static set (o, k, v) {
        let _o, _k;
        _o = o;
        _k = Array.isArray(k) ? k : k.split('.');
        for (let i = 0; i < _k.length; _o = _o[_k[i]], i++) {
          if (i === _k.length - 1)
            Object.defineProperty(_o, _k[i], {
              value: v,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else if (!ObjectAssistant['isEmpty'](_o[_k[i]]) || _o[_k[i]].constructor !== Object)
            _o[_k[i]] = {};
        }
      }

      /**
       * 判断对象是否为空
       * 若为以下值则为空:
       * null, undefined
       * 注意: 空值, 也就是'', 并不为空.
       *
       * @Author   Wolf
       * @DateTime 2020-09-03T22:57:53+0800
       * @return   {Boolean}                
       */
      static isEmpty (v) {
        return v === null || v === undefined;
      }

      /**
       * 判断对象是否为字符串
       *
       * @Author   Wolf
       * @DateTime 2020-09-24T01:35:38+0800
       * @param    {Mixed}                  v 
       * @return   {Boolean}                  
       */
      static isString (v) {
        return typeof v === 'string' || v instanceof String;
      }

      /**
       * 判断当前对象是否仅仅只是一个Object
       *
       * @Author   Wolf
       * @DateTime 2020-09-07T23:42:08+0800
       * @param    {Mixed}                 o  对象
       * @return   {Boolean}                  
       */
      static isOnlyObject (o) {
        return o && (o.constructor === Object || o.constructor === undefined);
      }

      /**
       * 根据当前实例往前找.
       * 返回父类classObject的method方法.
       * 若没有找到则返回null.
       *
       * @Author   Wolf
       * @DateTime 2020-09-03T17:02:04+0800
       * @param    {Object}                  instance     实例对象
       * @param    {Object}                  classObject  类对象
       * @param    {String}                  method       方法名称
       * @return   {Function}                             找到的方法
       */
      static getMethod (instance, classObject, method) {
        while(!ObjectAssistant['isEmpty'](instance)) {
          if (Object.is(instance.constructor, classObject))
            return instance[method];
          instance = instance.__proto__;
        }

        return null;
      }

      /**
       * 根据值获取对应的键值
       *
       * @Author   Wolf
       * @DateTime 2020-09-03T15:30:38+0800
       * @param    {Object}                 o 对象
       * @param    {Mixed}                  v 值
       * @return   {Mixed}                    键值
       */
      static getKeyByValue (o, v) {
        let key, entries;

        entries = Object.entries(o);
        for (let i = 0; i < entries.length; i++)
          if (entries[i][1] === v)
            return entries[i][0];

        return null;
      }

      /**
       * 深度拷贝一个对象
       * 待拷贝对象须支持枚举否则无法遍历
       *
       * @Author   Wolf
       * @DateTime 2020-09-01T20:49:17+0800
       * @param    {Object}                 object 原始对象
       * @return   {Object}                        新的对象
       */
      static deepCopy (obj) {
        let nObj, prevObj;
        let stack, _stack;
        let k, key, v, val;

        if (ObjectAssistant['isEmpty'](obj)) return obj;

        nObj = obj.constructor?.() ?? Object.create(null);
        _stack = [nObj];
        stack = [[Object.keys(obj), Object.values(obj)]];

        do {
          prevObj = _stack.shift();
          [key, val] = stack.shift();

          for (let i = 0; i < key.length; i++) {
            k = key[i], v = val[i];
            if (ObjectAssistant['isOnlyObject'](v) || Array.isArray(v)) {
              prevObj[k] = v.constructor?.() ?? Object.create(null);
              stack.push([Object.keys(v), Object.values(v)]);
              _stack.push(prevObj[k]);
            } else {
              prevObj[k] = v;
            }
          }
        } while (stack.length > 0);

        return nObj;
      }

      /**
       * 合并两个对象
       * 用sub的属性覆盖obj的属性.
       * 该合并为深度拷贝合并, 将会产生一个新的对象.
       *
       * @Author   Wolf
       * @DateTime 2020-09-01T20:58:58+0800
       * @param    {Object}                 sub  主体对象
       * @param    {Object}                 obj  次要对象
       * @return   {Object}                      合并后新的对象
       */
      static merge (sub, obj) {
        let nObj, prevObj;
        let stack, _stack;
        let k, _k, key, _key, totalKey, v, _v, val, _val;

        if (ObjectAssistant['isEmpty'](sub)) return obj;
        if (ObjectAssistant['isEmpty'](obj)) return sub;

        nObj = obj.constructor?.() ?? Object.create(null);
        _stack = [nObj];
        stack = [
          [
            [Object.keys(sub), Object.values(sub)],
            [Object.keys(obj), Object.values(obj)]
          ]
        ];

        do {
          prevObj = _stack.shift();
          [[key, val], [_key, _val]] = stack.shift();
          _key = [...new Set(_key.concat(key))];

          for (let i = 0; i < _key.length; i++) {
            let nCover;
            [_k, _v] = [_key[i], _val[i]];
            v = val[key.indexOf(_k)];
            nCover = ObjectAssistant['isEmpty'](v);
            if (ObjectAssistant['isOnlyObject'](_v) || Array.isArray(_v)) {
              let newEle = [];
              prevObj[_k] = (nCover ? _v.constructor : v.constructor)?.() ?? Object.create(null);
              newEle[1] = [Object.keys(_v), Object.values(_v)];
              newEle[0] = nCover ? [[], []] : [Object.keys(v), Object.values(v)];
              _stack.push(prevObj[_k]);
              stack.push(newEle);
            } else {
              Object.defineProperty(prevObj, _k, {
                'writable': true,
                'enumerable': true,
                'value': nCover ? _v : v
              })
            }
          }
        } while (stack.length > 0);

        return nObj;
      }
    }
class CacheAssistant {
  /**
   * 缓存符号
   *
   * @type {Symbol}
   */
  static _symbol = new Map;

  /**
   * 查询缓存是否存在
   *
   * @Author   Wolf
   * @DateTime 2020-09-25T23:21:16+0800
   * @param    {Mixed}                  k 缓存名称
   * @param    {Object}                 o 专属对象
   * @return   {Boolean}                  
   */
  static has (k, o = null) {
    let symbol;

    o = o ?? CacheAssistant;
    symbol = CacheAssistant['_symbol'].get(o);

    return symbol ? o[symbol].has(k) : false;
  }

  /**
   * 获取缓存
   *
   * @Author   Wolf
   * @DateTime 2020-09-25T23:01:44+0800
   * @param    {Mixed}                  k 缓存名称
   * @param    {Object}                 o 专属对象
   * @return   {Mixed}                    缓存内容
   */
  static get (k, o = null) {
    let symbol;

    o = o ?? CacheAssistant;
    symbol = CacheAssistant['_symbol'].get(o);

    return symbol ? o[symbol].get(k) : undefined;
  }

  /**
   * 设置缓存
   *
   * @Author   Wolf
   * @DateTime 2020-09-25T22:30:41+0800
   * @param    {Mixed}                  k 缓存名称
   * @param    {Mixed}                  v 缓存内容
   * @param    {Object}                 o 专属对象
   */
  static set (k, v, o = null) {
    let symbol;

    o = o ?? CacheAssistant;

    if (!CacheAssistant['_symbol'].has(o)) {
      symbol = Symbol('cache');
      CacheAssistant['_symbol'].set(o, symbol)
    } else {
      symbol = CacheAssistant['_symbol'].get(o);
    }

    if (!o.hasOwnProperty(symbol))
      Object.defineProperty(o, symbol, {
        'value': new Map,
        'writable': false,
        'enumerable': false,
        'configurable': false
      });

    o[symbol].set(k, v);
  }

  /**
   * 删除缓存
   *
   * @Author   Wolf
   * @DateTime 2020-09-25T23:10:56+0800
   * @param    {Mixed}                  k 缓存名称, 如果为空则删除当前对象的所有缓存
   * @param    {Object}                 o 专属对象
   */
  static delete (k = null, o = null) {
    let _o, symbol;

    o = o ?? CacheAssistant;
    symbol = CacheAssistant['_symbol'].get(o);

    if (k) {
      o[symbol].delete(k);
    } else {
      o[symbol].forEach((v, k) => {
        o[symbol].delete(k);
      });
    }
  }

  /**
   * 清除所有缓存
   *
   * @Author   Wolf
   * @DateTime 2020-09-25T23:12:31+0800
   */
  static clear () {
    CacheAssistant['_symbol'].forEach((v, k) => {
      CacheAssistant['delete'](null, k);
    });
  }
}    
    class CanvasAssistant {
      /**
       * 绘制文字
       *
       * @Author   Wolf
       * @DateTime 2020-09-25T23:41:05+0800
       * @param    {CanvasRenderingContext2D} ctx     画布对象
       * @param    {Object}                   options 相关设置
       */
      static drawText (ctx, options) {
        let _option, measureText;

        _option = {
          'text': null,
          'fill': true,
          'color': 'black',
          'direction': 'ltr',
          'textAlign': 'center',
          'textBaseline': 'middle',
          'font': 'normal 16px Microsoft YaHei, serif',
          'point': [ctx.canvas.width / 2, ctx.canvas.height / 2]
        };

        options = ObjectAssistant.merge(options, _option);

        if (!options['text']) return;

        ctx.save();

        ctx.font = options['font'];
        ctx.fillStyle = options['color'];
        ctx.direction = options['direction'];
        ctx.textAlign = options['textAlign'];
        ctx.textBaseline = options['textBaseline'];

        measureText = ctx.measureText(options['text']);
        options['point'][1] += measureText.actualBoundingBoxDescent / 2;

        if (options['fill'] === true)
          ctx.fillText(options['text'], ...options['point'], options['maxWidth']);
        else
          ctx.strokeText(options['text'], ...options['point'], options['maxWidth']);

        ctx.restore();
      }

      /**
       * 绘制一个圆
       *
       * @Author   Wolf
       * @DateTime 2020-09-25T23:26:29+0800
       * @param    {CanvasRenderingContext2D} ctx     画布对象
       * @param    {Object}                   options 相关设置
       */
      static drawRound (ctx, options) {
        let _option;

        _option = {
          'step': [],
          'radius': 5,
          'fill': true,
          'borderWidth': 5,
          'borderColor': 'black',
          'fillColor': 'transparent',
          'point': [ctx.canvas.width / 2, ctx.canvas.height / 2]
        }

        options = ObjectAssistant.merge(options, _option);

        ctx.save();

        ctx.fillStyle = options['fillColor'];
        ctx.lineWidth = options['borderWidth'];
        ctx.strokeStyle = options['borderColor'];

        ctx.beginPath();
        ctx.setLineDash(options['step']);
        ctx.arc(...options['point'], options['radius'], 0, 2 * window.Math.PI);
        ctx.stroke();

        if (options['fill'] === true) ctx.fill();

        ctx.restore();

      }
 
      /**
       * 绘制虚线圆形
       *
       * @Author   Wolf
       * @DateTime 2020-08-27T01:59:16+0800
       * @param    {Object}                 ctx    CanvasRenderingContext2D对象
       * @param    {Number}                 x      圆心所在x轴位置
       * @param    {Number}                 y      圆心所在y轴距离
       * @param    {Number}                 radius 半径
       * @param    {Number}                 step   每段圆弧之间的间距
       */
      static drawDashRound (ctx, x, y, radius, step = 5) {
        let count = window.Math.floor(360 / step);
        step = 5 / 180 * window.Math.PI * 2;
        for (let b = 0, e = step / 2; e <= 360; b += step, e += step) {
          ctx.beginPath()
          ctx.arc(x, y, radius, b, e);
          ctx.stroke();
        }
      }

      /**
       * 下载canvas中展示的图片
       *
       * @Author   wolf
       * @DateTime 2020-07-06T03:26:50+0800
       * @param    {Element}                canvas   画布对象
       * @param    {String}                 filename 图片名称
       * @param    {String}                 type     图片类型
       */
      static download (canvas, filename = 'canvas', type) {
        let node;

        if (CacheAssistant['has']('downloadNode', CanvasAssistant)) {
          node = CacheAssistant['get']('downloadNode', CanvasAssistant)
        } else {
          node = document.createElement('a');
          CacheAssistant['set']('downloadNode', node, CanvasAssistant);
        }

        node.download = filename;
        node.href = canvas.toDataURL(type);

        node.click();
      }
    }    


    class CanvasAnimationAssistant {

      static loadFailedFade (ctx, options) {
        let start, elapse, interval;
        let _fps, _opacity, _repaint;
        let iconKey, textKey, roundKey;
        let _cache, _option, frameAnimation;
        let speed, casIdx, opacity, direction;
        let casCenter, textCenter, roundCenter;
        let iconOption, textOption, roundOption, defaultOption;
        let iconCas, iconCtx, textCas, textCtx, roundCas, roundCtx;

        if (!(ctx instanceof CanvasRenderingContext2D))
          throw Error('Requires a value of type "CanvasRenderingContext2D"');

        if (ObjectAssistant.isEmpty(options))
          options = Object.create(null);

        _fps = 60;
        _opacity = 1;
        _repaint = 'animation-loadFailedFade-' + Date.now() + '-' + performance.now() + (options['sign'] ? ('-' + options['sign']) : '');

        iconOption = {
          'size': 72,
          'char': ['!', '?'],
          'color': 'rgba(220, 53, 69)',
          'font': 'bold 72px Microsoft YaHei, serif',
        };

        textOption = {
          'size': 16,
          'color': 'black',
          'text': 'Load Failed',
          'font': 'normal 16px Microsoft YaHei, serif',
        }

        roundOption = {
          'step': [5],
          'radius': 48,
          'fill': false,
          'borderWidth': 5,
          'fillColor': '#ddd',
          'borderColor': '#ddd'
        };

        defaultOption = {
          'duration': 4,
          'speed': null,
          'icon': iconOption,
          'text': textOption,
          'round': roundOption
        }

        _option = ObjectAssistant.merge(options, defaultOption);
        iconKey = JSON.stringify(_option['icon']);
        textKey = JSON.stringify(_option['text']);
        roundKey = JSON.stringify(_option['round']);
        _option['speed'] = _option['speed'] ?? _option['duration'] / (_option['icon']['char'].length * 2 * _opacity);

        if (!(_cache = CacheAssistant['get']('loadFailedFade', CanvasAnimationAssistant))) {
          _cache = new Map;
          CacheAssistant['set']('loadFailedFade', _cache, CanvasAnimationAssistant);
        }

        if (!(iconCas = _cache.get(iconKey))) {
          iconCas = [];
          for (let i = 0; i < iconOption['char'].length; i++) {
            iconCas[i] = document.createElement('canvas');
            iconCtx = iconCas[i].getContext('2d');
            iconOption['text'] = iconOption['char'][i];
            iconCas[i].width = iconCas[i].height = iconOption['size'];
            CanvasAssistant['drawText'](iconCtx, iconOption);
          }
          _cache.set(iconKey, iconCas);
        }

        if (!(textCas = _cache.get(textKey))) {
          textCas = document.createElement('canvas');
          textCtx = textCas.getContext('2d');
          textCas.height = textOption['size'] * 2;
          textCas.width = textOption['size'] * textOption['text'].length;
          CanvasAssistant['drawText'](textCtx, textOption);
          _cache.set(textKey, textCas);
        }

        if (!(roundCas = _cache.get(roundKey))) {
          roundCas = document.createElement('canvas');
          roundCtx = roundCas.getContext('2d');
          roundCas.width = roundCas.height = (roundOption['radius'] + roundOption['borderWidth']) * 2;
          CanvasAssistant['drawRound'](roundCtx, roundOption);
          _cache.set(roundKey, roundCas);
        }

        direction = 1;
        casIdx = opacity = 0;
        interval = 1000 / _fps;
        casCenter = [ctx.canvas.width / 2, ctx.canvas.height / 2];
        roundCenter = [roundCas.width / 2, roundCas.height / 2];
        textCenter = [textCas.width / 2, (textOption['size'] + roundCas.height) / 2];
        speed = _opacity / (_option['duration'] / iconCas.length / 2 * 1000 / interval);

        frameAnimation = function (timestamp) {
          let plusNum = speed * direction;

          ctx.clearRect(casCenter[0] - roundCenter[0], casCenter[1] - roundCenter[1], roundCas.width, roundCas.height);

          if (opacity + plusNum > 1) {
            opacity = 1;
            direction = -direction;
          } else if (opacity + plusNum < 0) {
            opacity = 0;
            direction = -direction;
            casIdx = casIdx + 1 < iconCas.length ? casIdx + 1 : 0;
          } else {
            opacity += plusNum;
          }

          ctx.globalAlpha = opacity;
          ctx.drawImage(iconCas[casIdx], casCenter[0] - iconCas[casIdx].width / 2, casCenter[1] - iconCas[casIdx].height / 2);
          ctx.globalAlpha = 1;
          ctx.drawImage(roundCas, casCenter[0] - roundCenter[0], casCenter[1] - roundCenter[1]);

          window.requestAnimationFrame(frameAnimation);
        }

        ctx.drawImage(textCas, casCenter[0] - textCenter[0], casCenter[1] + textCenter[1]);
        window.requestAnimationFrame(frameAnimation);

        return _repaint;
      }
    }

  </script>
</head>
<body>
  <canvas id="test-canvas" width="800" height="600" style="border: 1px solid black"></canvas>
<!--   <div id="test-event">
    <p><a href="javascript: void(0)" class="test-a" index="1">1爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="2">2爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="3">3爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="4">4爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="5">5爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="6">6爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="7">7爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="8">8爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="9">9爱神的箭卡省的</a></p>
  </div>
 --></body>
<script>
  /*
  var cas = document.querySelector('canvas');
  var ctx = cas.getContext('2d');

  function draw () {
    ctx.clearRect(0, 0, cas.width, cas.height);
    ctx.save();
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, cas.width, cas.height);
    ctx.translate(cas.width / 2, cas.height / 2);
    debugger;
    ctx.rotate(180 * Math.PI / 180);
    ctx.translate(-cas.width / 2, -cas.height / 2);
    ctx.fillStyle = 'blue';
    ctx.fillRect(0, 0, cas.width, cas.height);
    ctx.restore();
  }
  */
</script>
</html>