<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    class ObjectAssistant {
      /**
       * 获取对象上某个属性
       * 可以通过传入一串字符串或是数组进行深层的获取.
       * 若其中某一个属性值不存在则直接返回undefined;
       * 该函数行为于ES6新的运算符号?.相似.
       *
       * @Author   Wolf
       * @DateTime 2020-09-08T17:41:36+0800
       * @param    {Object}                 o 对象
       * @param    {Mixed}                  k 属性
       * @return   {Mixed}                    属性值
       */
      static get (o, k) {
        let _o, _k;
        _o = o;
        _k = Array.isArray(k) ? k : k.split('.');
        for (let i = 0; i < _k.length && !ObjectAssistant['isEmpty'](_o); i++)
          _o = _o[_k[i]];
        return _o;
      }

      /**
       * 设置一个属性到对象
       * 与默认赋值方法不同的是该方法可以通过传入一串字符串或数组进行级联赋值
       * 若父值不存在则自动赋值{}.
       * 
       * 注意:
       * 如果属性的父值不为Object则会将其重新赋值为Object.
       * 语义上该方法并不适用于数组.
       *
       * @Author   Wolf
       * @DateTime 2020-09-08T17:38:10+0800
       * @param    {Object}                 o 对象
       * @param    {Mixed}                  k 属性名称
       * @param    {Object}                 v 属性值
       */
      static set (o, k, v) {
        let _o, _k;
        _o = o;
        _k = Array.isArray(k) ? k : k.split('.');
        for (let i = 0; i < _k.length; _o = _o[_k[i]], i++) {
          if (i === _k.length - 1)
            Object.defineProperty(_o, _k[i], {
              value: v,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else if (!ObjectAssistant['isEmpty'](_o[_k[i]]) || _o[_k[i]].constructor !== Object)
            _o[_k[i]] = {};
        }
      }

      /**
       * 判断对象是否为空
       * 若为以下值则为空:
       * null, undefined
       * 注意: 空值, 也就是'', 并不为空.
       *
       * @Author   Wolf
       * @DateTime 2020-09-03T22:57:53+0800
       * @return   {Boolean}                
       */
      static isEmpty (v) {
        return v === null || v === undefined;
      }

      /**
       * 判断对象是否为字符串
       *
       * @Author   Wolf
       * @DateTime 2020-09-24T01:35:38+0800
       * @param    {Mixed}                  v 
       * @return   {Boolean}                  
       */
      static isString (v) {
        return typeof v === 'string' || v instanceof String;
      }

      /**
       * 判断当前对象是否仅仅只是一个Object
       *
       * @Author   Wolf
       * @DateTime 2020-09-07T23:42:08+0800
       * @param    {Mixed}                 o  对象
       * @return   {Boolean}                  
       */
      static isOnlyObject (o) {
        return o && (o.constructor === Object || o.constructor === undefined);
      }

      /**
       * 根据当前实例往前找.
       * 返回父类classObject的method方法.
       * 若没有找到则返回null.
       *
       * @Author   Wolf
       * @DateTime 2020-09-03T17:02:04+0800
       * @param    {Object}                  instance     实例对象
       * @param    {Object}                  classObject  类对象
       * @param    {String}                  method       方法名称
       * @return   {Function}                             找到的方法
       */
      static getMethod (instance, classObject, method) {
        while(!ObjectAssistant['isEmpty'](instance)) {
          if (Object.is(instance.constructor, classObject))
            return instance[method];
          instance = instance.__proto__;
        }

        return null;
      }

      /**
       * 根据值获取对应的键值
       *
       * @Author   Wolf
       * @DateTime 2020-09-03T15:30:38+0800
       * @param    {Object}                 o 对象
       * @param    {Mixed}                  v 值
       * @return   {Mixed}                    键值
       */
      static getKeyByValue (o, v) {
        let key, entries;

        entries = Object.entries(o);
        for (let i = 0; i < entries.length; i++)
          if (entries[i][1] === v)
            return entries[i][0];

        return null;
      }

      /**
       * 深度拷贝一个对象
       * 待拷贝对象须支持枚举否则无法遍历
       *
       * @Author   Wolf
       * @DateTime 2020-09-01T20:49:17+0800
       * @param    {Object}                 object 原始对象
       * @return   {Object}                        新的对象
       */
      static deepCopy (obj) {
        let nObj, prevObj;
        let stack, _stack;
        let k, key, v, val;

        if (ObjectAssistant['isEmpty'](obj)) return obj;

        nObj = obj.constructor?.() ?? Object.create(null);
        _stack = [nObj];
        stack = [[Object.keys(obj), Object.values(obj)]];

        do {
          prevObj = _stack.shift();
          [key, val] = stack.shift();

          for (let i = 0; i < key.length; i++) {
            k = key[i], v = val[i];
            if (ObjectAssistant['isOnlyObject'](v) || Array.isArray(v)) {
              prevObj[k] = v.constructor?.() ?? Object.create(null);
              stack.push([Object.keys(v), Object.values(v)]);
              _stack.push(prevObj[k]);
            } else {
              prevObj[k] = v;
            }
          }
        } while (stack.length > 0);

        return nObj;
      }

      /**
       * 合并两个对象
       * 用sub的属性覆盖obj的属性.
       * 该合并为深度拷贝合并, 将会产生一个新的对象.
       *
       * @Author   Wolf
       * @DateTime 2020-09-01T20:58:58+0800
       * @param    {Object}                 sub  主体对象
       * @param    {Object}                 obj  次要对象
       * @param    {Number}                 mode 如果出现重复值采取的动作[0: 深入补全, 1: 完全覆盖]
       * @return   {Object}                      合并后新的对象
       */
      static merge (sub, obj, mode = 0) {
        let nObj, prevObj;
        let stack, _stack;
        let k, _k, key, _key, totalKey, v, _v, val, _val;

        if (ObjectAssistant['isEmpty'](sub)) return obj;
        if (ObjectAssistant['isEmpty'](obj)) return sub;

        nObj = obj.constructor?.() ?? Object.create(null);
        _stack = [nObj];
        stack = [
          [
            [Object.keys(sub), Object.values(sub)],
            [Object.keys(obj), Object.values(obj)]
          ]
        ];

        do {
          prevObj = _stack.shift();
          [[key, val], [_key, _val]] = stack.shift();
          _key = [...new Set(_key.concat(key))];

          for (let i = 0; i < _key.length; i++) {
            let nCover;
            [_k, _v] = [_key[i], _val[i]];
            v = val[key.indexOf(_k)];
            nCover = ObjectAssistant['isEmpty'](v);
            if (ObjectAssistant['isOnlyObject'](_v) || Array.isArray(_v)) {
              let newEle = [];
              prevObj[_k] = (nCover ? _v.constructor : v.constructor)?.() ?? Object.create(null);
              newEle[1] = mode === 0 ? [Object.keys(_v), Object.values(_v)] : [Object.keys(v), []];
              newEle[0] = nCover ? [[], []] : [Object.keys(v), Object.values(v)];
              _stack.push(prevObj[_k]);
              stack.push(newEle);
            } else {
              Object.defineProperty(prevObj, _k, {
                'writable': true,
                'enumerable': true,
                'value': nCover ? _v : v
              })
            }
          }
        } while (stack.length > 0);

        return nObj;
      }
    }

    class EventAssistant {
      static #_event = new Map;

      static add (element, type, selector, callback, thisArg, parameter, options, wantsUntrusted = false) {
        let eventSymbol;
        let promise, usePromise;
        
        usePromise = false;
        eventSymbol = Symbol();

        if (!(element instanceof EventTarget)) {
          if (!(element = document.querySelector(element)))
            throw Error('Is not a valid element.');
        }

        if (!ObjectAssistant.isString(type))
          throw Error('Event type not allowed to be empty');

        if (selector instanceof EventTarget) {
          element = selector;
          selector = null;
        }

        if (!(callback instanceof Function))
          usePromise = true;

        if (ObjectAssistant.isEmpty(thisArg))
          thisArg = selector ?? element;

        if (!ObjectAssistant.isEmpty(parameter) && !Array.isArray(parameter))
          parameter = [parameter];

        if (ObjectAssistant.isEmpty(options))
          options = false;
          // options = {
          //   'once': false,
          //   'passive': false,
          //   'capture': false,
          //   'mozSystemGroup': false
          // };

        if (usePromise) {
          parameter = [{
            'target': thisArg,
            'symbol': eventSymbol,
            'parameter': parameter ?? []
          }]
        } else {
          parameter = parameter ?? [];
        }

        if (selector) { // 事件委托
          let delegate;
          let target, findElements;

          promise = new Promise(resolve => {
            delegate = function (event) {
              target = event.target;
              findElements = element.querySelectorAll(selector);

              // 忽略的情况
              //   如果触发元素是绑定元素本身或者其父元素.
              //   如果在父元素中没有找到触发元素.
              if (target.contains(element) || findElements.length === 0) return false;

              if (Reflect.apply(Array.prototype.includes, findElements, [target])) {
                if (usePromise) {
                  parameter[0]['event'] = event;
                  parameter[0]['target'] = thisArg === selector ? event.target : thisArg;
                } else {
                  parameter.push(event);
                }
                (usePromise ? resolve : callback).apply(thisArg === selector ? event.target : thisArg, parameter);
              }
            };

            EventAssistant.#_event.set(eventSymbol, {
              'type': type,
              'element': element,
              'options': options,
              'selector': selector,
              'callback': callback,
              'wantsUntrusted': wantsUntrusted            
            });

            element.addEventListener(type, delegate, options, wantsUntrusted);
          });

        } else { // 正常绑定
          promise = new Promise(resolve => {
            callback = (usePromise ? resolve : callback).bind(thisArg, ...parameter);
            EventAssistant.#_event.set(eventSymbol, {
              'type': type,
              'element': element,
              'options': options,
              'selector': selector,
              'callback': callback,
              'wantsUntrusted': wantsUntrusted
            });
            element.addEventListener(type, callback, options, wantsUntrusted);
          });
        }

        return usePromise ? promise : eventSymbol;
      }

      /**
       * 移除事件
       * 通过Symbol
       *
       * @Author   Wolf
       * @DateTime 2020-09-24T03:12:47+0800
       * @param    {Symbol}                 symbol 索引
       */
      static remove (symbol) {
        let eventOptions = EventAssistant.#_event['get'](symbol);
        if (eventOptions) {
          eventOptions['element'].removeEventListener(eventOptions['type'], eventOptions['callback'], eventOptions['options'], eventOptions['wantsUntrusted']);
          EventAssistant.#_event['delete'](symbol);
        }
      }

      static removeBy (key, value) {
        EventAssistant.#_event.forEach((v, k) => {
          if (v[key] === value) {
            v['element'].removeEventListener(v['type'], v['callback'], v['options'], v['wantsUntrusted']);
            EventAssistant.#_event['delete'](k);
          }
        });
      }

      static removeAll () {
        EventAssistant.#_event.forEach((v, k) => {
          v['element'].removeEventListener(v['type'], v['callback'], v['options'], v['wantsUntrusted']);
          EventAssistant.#_event['delete'](k);
        });
      }
    }
    
  </script>
</head>
<body>
  <canvas width="800" height="600" style="border: 1px solid black"></canvas>
  <div id="test-event">
    <p><a href="javascript: void(0)" class="test-a" index="1">1爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="2">2爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="3">3爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="4">4爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="5">5爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="6">6爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="7">7爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="8">8爱神的箭卡省的</a></p>
    <p><a href="javascript: void(0)" class="test-a" index="9">9爱神的箭卡省的</a></p>
  </div>
</body>
<script>
  /*
  var cas = document.querySelector('canvas');
  var ctx = cas.getContext('2d');

  function draw () {
    ctx.clearRect(0, 0, cas.width, cas.height);
    ctx.save();
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, cas.width, cas.height);
    ctx.translate(cas.width / 2, cas.height / 2);
    debugger;
    ctx.rotate(180 * Math.PI / 180);
    ctx.translate(-cas.width / 2, -cas.height / 2);
    ctx.fillStyle = 'blue';
    ctx.fillRect(0, 0, cas.width, cas.height);
    ctx.restore();
  }
  */
</script>
</html>